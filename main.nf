#!/usr/bin/env nextflow

// MASTER BRANCH
params.help = false
params.debug = false

// PRINT HELP AND EXIT
if(params.help){
println """\

         =================================================
          E P I D I V E R S E - E W A S   P I P E L I N E
         =================================================
         ~ version ${workflow.manifest.version}

         Usage: 

              You must first make the pipeline available using this command: nextflow pull https://bitbucket.org/epidiverse/ewas

              GEM_Emodel is used to find the association between methylation and environmental factor genome widely form using the following command:

	          nextflow run epidiverse/ewas --samples --meth_calls --GEM_Emodel

              GEM_Gmodel is to create a methQTL genome-wide map using the following command:

	          nextflow run epidiverse/ewas --samples --meth_calls --GEM_Gmodel

              GEM_GxEmodel is to test ability of the interaction of gene and environmental factor to predict DNA methylation level using the following command:

	          nextflow run epidiverse/ewas --samples --meth_calls --GEM_GXEmodel

         
         
         Options: GENERAL
     
              --input                         [REQUIRED] Specify input path for the directory containing each sample output from the WGBS pipeline 
                                              to be taken forward for analysis. All the subdirectories must correspond to sample names 
                                              in the provided samples file, and contain within them a bedGraph directories with files 
                                              in '*.bedGraph' format. [default: on]
                                              
                                                          
              --DMP                           Specify input path for the DMR pipeline output directory  to run EWAS analyses with DMPs 
                                              instead of the default input type methlation calls. [default: off]
         
              --DMR                           Specify input path for the DMR pipeline output directory  to run EWAS analyses with DMRs 
                                              instead of the default input type methlation calls. [default: off]
              
              
              --samples [path/to/samples.tsv] [REQUIRED] Specify the path to the "samples.tsv" file containing information  regarding 
                                              sample names and corresponding groupings/replicates. The file must contain three tab-separated 
                                              columns: 1) sample names, corresponding to subdirectories in the --methcalls directory. 
                                              2) group names, for grouping samples together. 3) replicate names to provide easy-to-read 
                                              alternatives for complicated sample names. 4) Environment value [int]. 
              
                                               

              --snp                           [path/to/snp_file] [REQUIRED for GEM_G and GEM_GXE Models run]. A subset with genotype data 
                                              encoded as 1,2,3 for major allele homozygote (AA), heterozygote (AB) and minor allele homozygote 
                                              (BB) for all SNPs across all samples. This file either can be generated by user or ... fill this part. 

              --output [STR]                  A string that will be used as the name for the output results directory, which will be generated 
                                              in the working directory. This directory will contain sub-directories for each set of reads analysed 
                                              during the pipeline. [default: 'ewas']


         Options: MODIFIERS

                                         
              --noCpG                        Disables DMR analysis in CpG context. [default: off] 
              --noCHG                        Disables DMR analysis in CHG context. [default: off]
              --noCHH                        Disables DMR analysis in CHH context. [default: off]
              
  
  
         
         Options: EWAS FILTERING
         
              --coverage [INT]              Specify the minimum coverage threshold to filter methylated positions before running
                                            the EWAS analyses with methylation calls input type. [default: 0] If user would like 
                                            to run the pipeline with DMP and/or DMR input options, then coverage filter has to be 
                                            applied via EpiDiverse DMR pipeline.
         
              --sig                         Specify the maximum p-value threshold for filtering EWAS post-analysis. [default: 0.05]
              
              --FDR                         Specify the maximum FDR threshold for filtering EWAS post-analysis. [default: 0.05]

        
        Options: DEVELOPER USE
         
              --debug                       Prevent nextflow from clearing the cache on completion of the pipeline. This
                                            includes '.work' and '.nextflow' directories and any log files that have been
                                            created. [default: off]

         
         
"""
if (params.debug == false) { ["bash", "${baseDir}/bin/clean.sh", "${workflow.sessionId}"].execute() }
exit 1
}



// DECLARE PIPELINE PARAMETERS
params.output          = "ewas"
params.samples         = false
params.snp             = false
params.input           = false
params.DMP             = false
params.DMR             = false
params.GEM_Emodel      = false
params.GEM_Gmodel      = false
params.GEM_GXEmodel    = false  
output_path            = "$PWD/${params.output}"


params.noCpG = false
params.noCHG = false
params.noCHH = false

params.coverage = "0"
params.Emodel_pv = "1e-04"
params.Gmodel_pv = "1e-04"
params.GXEmodel_pv = "1e-04"
params.sig = "0.05"
params.FDR = "0.05"



// DEFINE MODEL TYPE FOR GEM RUN
def modelLine = ""
if( params.GEM_Emodel == true ){ modelLine += "GEM_Emodel," }
if( params.GEM_Gmodel == true ){ modelLine += "GEM_Gmodel," }
if( params.GEM_GXEmodel == true ){ modelLine += "GEM_GXEmodel," }
if( (params.GEM_Emodel == false) && (params.GEM_Gmodel == false) && (params.GEM_GXEmodel == false) ){error "ERROR: please specify at least one model type for GEM run"}



// DEFINE CONTEXTLINE FOR INPUT PATH
def contextLine = ""
if( params.noCpG == false ){ contextLine += "CpG," }
if( params.noCHG == false ){ contextLine += "CHG," }
if( params.noCHH == false ){ contextLine += "CHH," }
if( params.noCpG && params.noCHG && params.noCHH ){error "ERROR: please specify at least one methylation context for analysis"}



def commaLine = ""
file("${params.samples}")
    .readLines()
    .each { def line = it.toString().tokenize('\t').get(0) 
         commaLine += line
         commaLine += "," }

//bedGraph_path = "${params.methcalls}/{${commaLine[0..-2]}}/bedGraph/*_{${contextLine[0..-2]}}.bedGraph"
results_path = "$PWD/${params.output}"
//DMP_path = "${params.DMP}/{${contextLine[0..-2]}}/metilene/*.txt"

// PRINT STANDARD LOGGING INFO
log.info ""
log.info "         ================================================"
log.info "          E P I D I V E R S E - E W A S    P I P E L I N E"
if(params.debug){
log.info "         (debug mode enabled)"
log.info "         ================================================" }
else {
log.info "         ================================================" }
log.info ""
log.info "         samples file                    : ${params.samples}"
log.info "         context(s)                      : ${params.noCpG ? "" : "CpG "}${params.noCHH ? "" : "CHH "}${params.noCHG ? "" : "CHG"}"
log.info "         snp file                        : ${params.snp}"
log.info "         meth calls dir                  : ${params.input}"
log.info "         DMR input                       : ${params.DMR}"
log.info "         DMP input                       : ${params.DMP}"
log.info "         output dir                      : ${params.output}"

log.info ""
log.info "         GEM Parameters"
log.info "         ================================================"
log.info "         Emodel p_value                  : ${params.Emodel_pv}"
log.info "         Gmodel p_value                  : ${params.Gmodel_pv}"
log.info "         GXEmodel p_value                : ${params.GXEmodel_pv}"
log.info "         GEM_Emodel                      : ${params.GEM_Emodel}"
log.info "         GEM_Gmodel                      : ${params.GEM_Gmodel}"
log.info "         GEM_GXEmodel                    : ${params.GEM_GXEmodel}"
log.info ""
log.info "         EWAS CpG-Filtering"
log.info "         ================================================"
log.info "         significance  : ${params.sig}"
log.info "         FDR           : ${params.FDR}"
log.info "         coverage      : ${params.coverage}"
log.info ""
log.info "         ================================================"
log.info ""



////////////////////
// BEGIN PIPELINE //
////////////////////


// set samples file
samples_file = file("${params.samples}", checkIfExists: true)


// STAGE SAMPLES CHANNEL for methylation calls
//I decided to make sample file with five columns. User can use exactly the same sample file for DMR pipeline run
//columns will be like
//#1 sample identifier
//#2group identifier
//#3 rep identifier
//#4 env values (int)
//#5 cov values (int)

// STAGE SAMPLES CHANNEL for methylation calls, DMPs and DMRs
Channel
    .from(samples_file.readLines())
    .map { line ->
         def field = line.toString().tokenize('\t').take(3)
         return tuple(field[0].replaceAll("\\s",""), field[1].replaceAll("\\s",""), field[2].replaceAll("\\s",""))}
    .into{ samples_bedGraph; samples_bedGraph2; samples_bedGraph3; samples_env_cov_DMP; samples_env_cov_DMR }
// eg. [name1, group1, rep1, env1, cov1],[name2, group1, rep2, env2, cov2]

//depending on the input type (eg. methcalls, DMPs and DMRs), conditions were set for making a decision and separated for each context
//this is also somehow good for checking if user will decide to run the pipeline with his/her input in the future, we will know whether he/she has correct files for running the pipeline
//old pattern trials did not work properly
//pattern = ~/\d\.\d+/
//pattern = "[0-9].[0-9]\+" 
//pattern = "[0-9].?"
//pattern = "[0-9].[0-9]*"
//pattern= ~/.\d.\d+$/


if (params.DMP && params.DMR) {
    println 'ERROR: Please specify at most one input type!'
}
else if (params.DMP) {   
    CpG_metilene_path        = "${params.DMP}/CpG/metilene/*" 
    CHG_metilene_path        = "${params.DMP}/CHG/metilene/*"
    CHH_metilene_path        = "${params.DMP}/CHH/metilene/*"   
}
else if (params.DMR) {   
    CpG_metilene_path        = "${params.DMR}/CpG/metilene/*" 
    CHG_metilene_path        = "${params.DMR}/CHG/metilene/*"
    CHH_metilene_path        = "${params.DMR}/CHH/metilene/*"   
}


CpG_path = "${params.input}/{${commaLine[0..-2]}}/bedGraph/*CpG.bedGraph"
CHG_path = "${params.input}/{${commaLine[0..-2]}}/bedGraph/*CHG.bedGraph"
CHH_path = "${params.input}/{${commaLine[0..-2]}}/bedGraph/*CHH.bedGraph"


//CpG_path                 = ["${params.input}/CpG/metilene/*.bed", "{params.input}/CpG/input/*.txt"]
//CpG_path                 = tuple("${params.input}/CpG/metilene/*[\\d].[\\d+].bed", "${params.input}/CpG/input/*.txt")
//CpG_path                 = tuple("${params.input}/CpG/metilene/*[0-9].[0-9][0-9].bed", "${params.input}/CpG/input/*.txt")



// STAGE DMP,DMR and METHCALLS INPUT DIRECTORIES 


//METHCALLS CHANNELS FOR ALL CONTEXTS
//eg [group1_vs_group2.0.05.bed]
bedGraph_channel1 = params.noCpG  ? Channel.empty() :
Channel
    .fromFilePairs( CpG_path, size: 1)
    .ifEmpty{ exit 1, "ERROR: 2: ${params.input}\n"}
    .set{CpG_input1}

//bedGraph_channel1.into{CpG_input1; CpG_input2; CpG_input3}
methcalls1 = (params.noCpG  ? Channel.empty() :CpG_input1.combine(samples_bedGraph, by: 0).map{tuple("CpG", *it)})

//CHG input channel
bedGraph_channel2 = params.noCHG  ? Channel.empty() :
Channel
    .fromFilePairs( CHG_path, size: 1)
    .ifEmpty{ exit 1, "ERROR: 2: ${params.input}\n"}
    .set{CHG_input1}
 
methcalls2 =(params.noCHG  ? Channel.empty() : CHG_input1.combine(samples_bedGraph2, by: 0).map{tuple("CHG", *it)})

//CHH input channel
bedGraph_channel3 = params.noCHH  ? Channel.empty() :
Channel
    .fromFilePairs( CHH_path, size: 1)
    .ifEmpty{ exit 1, "ERROR: 2: ${params.input}\n"}
    .set{CHH_input1}
methcalls3 = (params.noCHH  ? Channel.empty() :CHH_input1.combine(samples_bedGraph3, by: 0).map{tuple("CHH", *it)})

methcalls= methcalls1.mix(methcalls2).mix(methcalls3)
//methcalls.view()


//DMP CHANNELS FOR ALL CONTEXTS
//CpG DMP channel
metilene_channel1= params.noCpG || !params.DMP  ? Channel.empty() :
Channel
    .fromFilePairs( CpG_metilene_path,  type: 'dir', size:1)
    .ifEmpty{ exit 1, "ERROR: No input found in: ${params.DMP}\n" }

DMPs1 = (params.noCpG  ? Channel.empty() : metilene_channel1.map{tuple("CpG", *it)}.groupTuple())

metilene_channel3= params.noCHG  || !params.DMP ? Channel.empty() :
Channel
    .fromFilePairs( CHG_metilene_path, type: 'dir', size: 1)
    .ifEmpty{ exit 1, "ERROR: 1: ${params.DMP}\n" }
DMPs2 = (params.noCHG  ? Channel.empty() : metilene_channel3.map{tuple("CHG", *it)}.groupTuple())


metilene_channel5= params.noCHH  || !params.DMP ? Channel.empty() :
Channel
    .fromFilePairs( CHH_metilene_path, type: 'dir', size: 1)
    .ifEmpty{ exit 1, "ERROR: 1: ${params.DMP}\n" }
DMPs3 = (params.noCHH  ? Channel.empty() :metilene_channel5.map{tuple("CHH", *it)}.groupTuple())

DMPs= DMPs1.mix(DMPs2).mix(DMPs3)



//DMR CHANNELS FOR ALL CONTEXTS
//CpG DMR channel
metilene_channel2= params.noCpG  || !params.DMR ? Channel.empty() :
Channel
    .fromFilePairs( CpG_metilene_path, type: 'dir', size: 1)
    .ifEmpty{ exit 1, "ERROR: No input found in: ${params.DMR}\n" }

DMRs1 = (params.noCpG  ? Channel.empty() :metilene_channel2.map{tuple("CpG", *it)}.groupTuple())


metilene_channel4= params.noCHG  || !params.DMR ? Channel.empty() :
Channel
    .fromFilePairs( CHG_metilene_path, type: 'dir', size: 1)
    .ifEmpty{ exit 1, "ERROR: 1: ${params.DMR}\n" }
DMRs2 = (params.noCHG  ? Channel.empty() : metilene_channel4.map{tuple("CHG", *it)}.groupTuple())


metilene_channel6= params.noCHH  || !params.DMR ? Channel.empty() :
Channel
    .fromFilePairs( CHH_metilene_path, type: 'dir', size: 1)
    .ifEmpty{ exit 1, "ERROR: 1: ${params.DMR}\n" }
DMRs3 =(params.noCHH  ? Channel.empty() : metilene_channel6.map{tuple("CHH", *it)}.groupTuple())

DMRs= DMRs1.mix(DMRs2).mix(DMRs3)



// BEGIN PIPELINE

// taking sample.tsv and generating env.txt and cov.txt for all input types (meth. calls, DMPs and DMRs)

process "process_cov_and_env_files" {

    label "low"
    publishDir "${output_path}/meth_calls", mode: 'copy'
    if(params.DMP){publishDir "${output_path}/DMPs", mode: 'copy'}
    if(params.DMR){publishDir "${output_path}/DMRs", mode: 'copy'}

    input: 
    file samples from samples_file

    output:   
    file "env.txt" into environment_methcalls, environment_DMPs, environment_DMRs, env,gxe
    file "cov.txt" into covariate_methcalls, covariate_DMPs, covariate_DMRs, cov_gxe
                  
    script:
    """
    #!/bin/bash
    sed '/[0-9]\\,/s/\\,/./g' ${samples} | awk -F "\\t" '{printf \"%s\t%.6f",\$1,\$2; for(i=3; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' | awk -F "\\t" '{printf \"%s\\t%s\",\$1,\$2; for(i=3; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' > samples2.txt
    cat samples2.txt |grep '[0-9]'| sed 's/,//g' > samples3.txt
    echo -e "ID\tenv" | cat - samples3.txt > samples4.txt
    cat <(cut -f1 samples4.txt | paste -s) <(cut -f2 samples4.txt | paste -s) > env.txt
    cut -f1 samples3.txt > header.txt
    cut -d \$'\\t' -f3- samples3.txt  > pre_cov.txt
    paste header.txt pre_cov.txt > 2pre_cov.txt
     awk 'NR==1{printf "ID"; for(i=1; i<=NF-1; i++) h=h OFS "cov" i; print h}1' OFS='\t' 2pre_cov.txt > 3pre_cov.txt
    cat 3pre_cov.txt | datamash transpose | tr -d "\\r" > cov.txt    
   
   """
}

/*

process "process_gxe_file" {

    label "low"
    publishDir "${output_path}/GEM_GXEmodel/input", mode: 'copy'
   
    input:
    file cov from cov_gxe
    file env from env_gxe

    output:
    file("gxe.txt") into gxe_methcalls, gxe_DMPs, gxe_DMRs
    
    when:
    params.GEM_GXEmodel
    
    script:
    """
    #!/bin/bash
    head -n 1 ${env} > 2env.txt
    paste ${cov} 2env.txt > gxe.txt
    """  
} 

*/

process "process_input_files_meth_calls" {

    label "low"
    //publishDir "${output_path}/meth_calls/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
    set context, sample, file(bedGraph), env, cov from methcalls

    output:
    set context, sample, file("*.txt"), env, cov into cut1, cut2, cut3
    // eg. [CpG, samplename, bedgraph.txt]
    

    script:
    """
    #!/bin/bash
    tail -n+2 ${bedGraph} | awk 'BEGIN{OFS=\"\\t\"} {if((\$5+\$6)>=${params.coverage}) {printf \"%s\\t%s\\t%s\\t%1.2f\\n\", \$1,\$2,\$3,(\$4/100)}}' > ${bedGraph}.txt
    """  
} 


//DMP INPUT SECTION
// taking lists of files with with DMPs and merging into GEM E_model methylation input format


process "process_bedtools_unionbedg_methcalls1" {

    label "low"
    publishDir "${output_path}/DMPs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:   
    set context, samples, file(bedGraph), env, cov  from cut1.groupTuple()

    output:
    set context, samples, file("methylation.txt"), env, cov into bedGraph_DMPs
    
    when:
    params.DMP

    script:
    """
    #!/bin/bash
    bedtools unionbedg -filler NA -i ${bedGraph} -header -names ${samples.join(" ")} | awk -F "\\t" '{printf \"%s\t%s\t%s",\$1,\$2,\$3; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' | sed 's/NA/ /g' > methylation.txt 
 
    """  
} 


process "process_bedtools_unionbedg_methcalls2" {

    label "low"
    //publishDir "${output_path}/meth_calls/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
   
    set context, samples, file(bedGraph), env, cov  from cut2.groupTuple()

    output:
    set context, samples, file("methylation2.txt"), env, cov into bedGraph_methcalls
    
    when:
    !params.DMP && !params.DMR
        
    script:
    """
    #!/bin/bash
    bedtools unionbedg -filler NA -i ${bedGraph} -header -names ${samples.join(" ")} | awk -F "\\t" '{printf \"%s_%s\",\$1,\$2; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' | sed 's/NA/ /g' > methylation2.txt 
    
    """  
} 

process "process_bedtools_unionbedg_methcalls3" {

    label "low"
    //publishDir "${output_path}/DMRs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:   
    set context, samples, file(bedGraph), env, cov  from cut3.groupTuple()

    output:
    set context, samples, file("methylation.txt"), env, cov into bedGraph_DMRs
    
    when:
    params.DMR

    script:
    """
    #!/bin/bash
    bedtools unionbedg -filler NA -i ${bedGraph} -header -names ${samples.join(" ")} | awk -F "\\t" '{printf \"%s\t%s\t%s",\$1,\$2,\$3; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' | sed 's/NA/ /g' > methylation.txt 
    
    """  
} 



//use this inside GEM for methcalls
//bedtools unionbedg -filler NA -i ${bed} -header -names ${samples.join(" ")} | awk -F "\\t" '{printf \"%s_%s\",\$1,\$2; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' | sed 's/NA/ /g' > methylation2.txt 



// RUN GEM with methylation calls
process "process_GEM_Emodel_run_meth_calls" {
    
    label "low"    
    publishDir "${output_path}/meth_calls/${context}/GEM_Emodel", mode: 'copy'
    
    //beforeScript "${workflow.profile == "standard" || workflow.profile == "diverse" ? 'source activate /scr/epi/pipelines/ewas/libs/gem' : ''}"
    //afterScript "${workflow.profile == "standard" || workflow.profile == "diverse" ? 'conda deactivate /scr/epi/pipelines/ewas/libs/gem' : ''}"

    input:
    file envs from environment_methcalls
    file covs from covariate_methcalls
    set context, samples, file (meth), env, cov from bedGraph_methcalls
    
    output:
    file("emodel.txt")
    file("filtered_emodel.txt")
    file("emodel.png") 

    when:    
    !params.DMP && !params.DMR
    
    script: 
    """
    Rscript ${baseDir}/bin/GEM_Emodel_methcalls.R ${envs} ${covs} ${meth} ${params.Emodel_pv} > emodel.txt
    sort -n emodel.txt | awk 'BEGIN{OFS=\"\\t\"} {if((\$4)<=${params.sig} && (\$5)<=${params.FDR}) {printf \"%s\\t%s\\t%s\\t%s\\t%s\\n\", \$1,\$2,\$3,\$4,\$5}}' > filtered_emodel.txt    
    """
}

/*

//
//
//
//
//
//DMP PROCESS STARTS
process "process_bedtools_unionbedg_DMPs" {

    label "low"
    //publishDir "${output_path}/DMPs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
    set context, pairwise, file(bed) from DMPs.map{tuple(it[0],it[1],tuple(it[2].flatten()))}
   
    output:
    
    set context, pairwise, file("dmp.txt")  into pre_DMP 
    
    when:    
    params.DMP
   
    script:
    """
    #!/bin/bash
    
    find . -mindepth 1 -maxdepth 1 -type l | while read dir; do file=\$(ls \$dir/*.bed | awk 'BEGIN{OFS="\\t"} {print length,\$0}' | sort -nrk1 | head -1 | cut -f2); cut -f1,2,3,4 \$file > \$(basename \$file); done
    bedtools unionbedg -i *.bed > 2pre_dmp.txt
    cut -f1,2,3,4 2pre_dmp.txt > dmp.txt
    
    """  
} 



process "process_bedtools_intersect_DMP" {

    label "low"
    //publishDir "${output_path}/DMPs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
      
    set context, pairwise, file (dmp) from pre_DMP
    set context, samples, file (meth), env, cov from bedGraph_DMPs
   
    output:
    set context, pairwise, file("methylation_DMP.txt") into methylation_DMP 
     
    when:    
    params.DMP
   
    script:
    """
    #!/bin/bash
    head -1 ${meth} > header.txt
    sed '1d' ${meth} > 2meth.txt
    awk '{if(\$2<\$3) {printf \"\\t%s\",\$i}; print null}' ${dmp} > 2dmp.txt
    bedtools intersect -a 2meth.txt -b 2dmp.txt > pre_dmp.txt
    cat header.txt pre_dmp.txt > 2pre_dmp.txt 
    cat 2pre_dmp.txt | awk -F "\\t" '{printf \"%s_%s\",\$1,\$2; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' > methylation_DMP.txt
 
    """  
} 
//cat header.txt 2meth.txt > methylation_DMP.txt
//    bedtools intersect -a 2meth.txt -b ${dmp} > 3meth.txt
//    cat header.txt 3meth.txt > methylation_DMP.txt

//file("methylation.txt") from bedGraph_DMPs
//   bedtools intersect -a methylation.txt -b dmp.txt > pre2meth.txt
//    cat header.txt pre2meth.txt > methylation_DMP.txt



process "process_GEM_Emodel_run_DMPs" {
    
    label "low"    
    publishDir "${output_path}/DMPs/${context}/GEM_Emodel", mode: 'copy'
    

    input:
    file envs from environment_DMPs
    file covs from covariate_DMPs
    set context, pairwise, file (meth) from methylation_DMP

    output:
    file("emodel.txt")
    file("filtered_emodel.txt")
    file("emodel.png") 

    when: 
    params.DMP
    
    script: 
    """
    Rscript ${baseDir}/bin/GEM_Emodel_methcalls.R ${envs} ${covs} ${meth} ${params.Emodel_pv} > emodel.txt
    sort -n emodel.txt | awk 'BEGIN{OFS=\"\\t\"} {if((\$4)<=${params.sig} && (\$5)<=${params.FDR}) {printf \"%s\\t%s\\t%s\\t%s\\t%s\\n\", \$1,\$2,\$3,\$4,\$5}}' > filtered_emodel.txt        
    """
}

*/

//
//
//
//
//
//DMR PROCESS STARTS
process "process_bedtools_unionbedg_DMRs" {

    label "low"
    //publishDir "${output_path}/DMRs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
    set context, pairwise, file(bed) from DMRs.map{tuple(it[0],it[1],tuple(it[2].flatten()))}
   
    output:
    
    set context, pairwise, file("dmr.txt")  into pre_DMR 
    
    when:    
    params.DMR
   
    script:
    """
    #!/bin/bash
    
    find . -mindepth 1 -maxdepth 1 -type l | while read dir; do file=\$(ls \$dir/*.bed | awk 'BEGIN{OFS="\\t"} {print length,\$0}' | sort -nrk1 | head -1 | cut -f2); cut -f1,2,3,4 \$file > \$(basename \$file); done
    bedtools unionbedg -i *.bed > 2pre_dmr.txt
    cut -f1,2,3,4 2pre_dmr.txt > dmr.txt
    
    """  
} 



process "process_bedtools_intersect_DMR" {

    label "low"
    //publishDir "${output_path}/DMRs/${context}/GEM_Emodel/input", mode: 'copy'
   
    input:
      
    set context, pairwise, file (dmr) from pre_DMR
    set context, samples, file (meth), env, cov from bedGraph_DMRs
   
    output:
    set context, pairwise, file("methylation_DMR.txt") into methylation_DMR 
     
    when:    
    params.DMR
   
    script:
    """
    #!/bin/bash
    head -1 ${meth} > header.txt
    sed '1d' ${meth} > 2meth.txt
    awk '{if(\$2<\$3) {print \$0}}' ${dmr} > 2dmr.txt
    bedtools intersect -a 2meth.txt -b 2dmr.txt > pre_dmr.txt
    cat header.txt pre_dmr.txt > 2pre_dmr.txt 
    cat 2pre_dmr.txt | awk -F "\\t" '{printf \"%s_%s\",\$1,\$2; for(i=4; i<=NF; i++) {printf \"\\t%s\",\$i}; print null}' > methylation_DMR.txt
 
    """  
} 

process "process_GEM_Emodel_run_DMRs" {
    
    label "low"    
    publishDir "${output_path}/DMRs/${context}/GEM_Emodel", mode: 'copy'
    

    input:
    file envs from environment_DMRs
    file covs from covariate_DMRs
    set context, pairwise, file (meth) from methylation_DMR

    output:
    file("emodel.txt") 
    file("emodel.png") 
    file("filtered_emodel.txt")

    when:   
    params.DMR
    
    script: 
    """
    Rscript ${baseDir}/bin/GEM_Emodel_methcalls.R ${envs} ${covs} ${meth} ${params.Emodel_pv} > emodel.txt
    sort -n emodel.txt | awk 'BEGIN{OFS=\"\\t\"} {if((\$4)<=${params.sig} && (\$5)<=${params.FDR}) {printf \"%s\\t%s\\t%s\\t%s\\t%s\\n\", \$1,\$2,\$3,\$4,\$5}}' > filtered_emodel.txt    
   
    """
}



// WORKFLOW TRACING
workflow.onError {

log.info "Oops... Pipeline execution stopped with the following message: ${workflow.errorMessage}"
}


workflow.onComplete {

log.info ""
log.info "         Pipeline execution summary"
log.info "         ---------------------------"
log.info "         Completed at : ${workflow.complete}"
log.info "         Duration     : ${workflow.duration}"
log.info "         Status       : ${workflow.success ? "success" : "failed"}"
log.info "         workDir      : ${workflow.workDir} ${params.debug || !workflow.success ? "" : "(cleared)" }"
log.info "         exit status  : ${workflow.exitStatus}"
log.info "         Error report : ${workflow.errorReport ?: "-"}"
log.info ""

  if (params.debug == false && workflow.success) { ["bash", "${baseDir}/bin/clean.sh", "${workflow.sessionId}"].execute() }
}